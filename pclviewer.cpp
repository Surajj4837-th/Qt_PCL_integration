#include "pclviewer.h"
#include "ui_pclviewer.h"

PCLViewer::PCLViewer (QWidget *parent) : QMainWindow (parent),
    ui (new Ui::PCLViewer)
{
  ui->setupUi (this);
  this->setWindowTitle ("PCL viewer");

  // Setup the cloud pointer
  cloud.reset (new PointCloudT);
  // The number of points in the cloud
  cloud->points.resize (200);
/*We include the class header and the header for the UI object; note that this file is generated by the moc and it’s path depend on where you call cmake !

After that is the constructor implementation; we setup the ui and the window title name. | Then we initialize the cloud pointer member of the class at a newly allocated point cloud pointer. | The cloud is resized to be able to hold 200 points.
*/

  // The default color
  red   = 128;
  green = 128;
  blue  = 128;

  // Fill the cloud with some points
  for (auto& point: *cloud)
  {
    point.x = 1024 * rand () / (RAND_MAX + 1.0f);
    point.y = 1024 * rand () / (RAND_MAX + 1.0f);
    point.z = 1024 * rand () / (RAND_MAX + 1.0f);

    point.r = red;
    point.g = green;
    point.b = blue;
  }
/*red green and blue protected members are initialized to their default values.
The cloud is filled with random points (in a cube) and accordingly to red green and blue colors.*/

  // Set up the QVTK window
  viewer.reset (new pcl::visualization::PCLVisualizer ("viewer", false));
  ui->qvtkWidget->SetRenderWindow (viewer->getRenderWindow ());
  viewer->setupInteractor (ui->qvtkWidget->GetInteractor (), ui->qvtkWidget->GetRenderWindow ());
  ui->qvtkWidget->update ();
/*Here we create a PCL Visualizer name viewer and we also specify that we don’t want an interactor to be created.
We don’t want an interactor to be created because our qvtkWidget is already an interactor and it’s the one we want to use.
So the next step is to configure our newly created PCL Visualiser interactor to use the qvtkWidget.
The update() method of the qvtkWidget should be called each time you modify the PCL visualizer; if you don’t call it you don’t know if the visualizer will be updated before the user try to pan/spin/zoom.
*/
  // Connect "random" button and the function
  connect (ui->pushButton_random,  SIGNAL (clicked ()), this, SLOT (randomButtonPressed ()));

  // Connect R,G,B sliders and their functions
  connect (ui->horizontalSlider_R, SIGNAL (valueChanged (int)), this, SLOT (redSliderValueChanged (int)));
  connect (ui->horizontalSlider_G, SIGNAL (valueChanged (int)), this, SLOT (greenSliderValueChanged (int)));
  connect (ui->horizontalSlider_B, SIGNAL (valueChanged (int)), this, SLOT (blueSliderValueChanged (int)));
  connect (ui->horizontalSlider_R, SIGNAL (sliderReleased ()), this, SLOT (RGBsliderReleased ()));
  connect (ui->horizontalSlider_G, SIGNAL (sliderReleased ()), this, SLOT (RGBsliderReleased ()));
  connect (ui->horizontalSlider_B, SIGNAL (sliderReleased ()), this, SLOT (RGBsliderReleased ()));

  // Connect point size slider
  connect (ui->horizontalSlider_p, SIGNAL (valueChanged (int)), this, SLOT (pSliderValueChanged (int)));
/*Here we connect slots and signals, this links UI actions to functions. Here is a summary of what we have linked :
pushButton_random:
if button is pressed call randomButtonPressed ()
horizontalSlider_R:
if slider value is changed call redSliderValueChanged(int) with the new value as argument
if slider is released call RGBsliderReleased()
horizontalSlider_G:
if slider value is changed call (int) with the new value as argument
if slider is released call RGBsliderReleased()
horizontalSlider_B:
if slider value is changed call redSliderValueChanged(int) with the new value as argument
if slider is released call RGBsliderReleased()*/
  viewer->addPointCloud (cloud, "cloud");
  pSliderValueChanged (2);
  viewer->resetCamera ();
  ui->qvtkWidget->update ();
}
/*This is the last part of our constructor; we add the point cloud to the visualizer, call the method pSliderValueChanged to change the point size to 2.
We finally reset the camera within the PCL Visualizer not avoid the user having to zoom out and update the qvtkwidget to be sure the modifications will be displayed.
*/
void
PCLViewer::randomButtonPressed ()
{
  printf ("Random button was pressed\n");

  // Set the new color
  for (auto& point: *cloud)
  {
    point.r = 255 *(1024 * rand () / (RAND_MAX + 1.0f));
    point.g = 255 *(1024 * rand () / (RAND_MAX + 1.0f));
    point.b = 255 *(1024 * rand () / (RAND_MAX + 1.0f));
  }

  viewer->updatePointCloud (cloud, "cloud");
  ui->qvtkWidget->update ();
}
/*This is the public slot function member called when the push button “Random” is pressed.
The for loop iterates through the point cloud and changes point cloud color to a random number (between 0 and 255).
The point cloud is then updated and so the qtvtkwidget is.*/
void
PCLViewer::RGBsliderReleased ()
{
  // Set the new color
  for (auto& point: *cloud)
  {
    point.r = red;
    point.g = green;
    point.b = blue;
  }
  viewer->updatePointCloud (cloud, "cloud");
  ui->qvtkWidget->update ();
}
/*This is the public slot function member called whenever the red, green or blue slider is released
The for loop iterates through the point cloud and changes point cloud color to red, green and blue member values.
The point cloud is then updated and so the qtvtkwidget is.
*/
void
PCLViewer::redSliderValueChanged (int value)
{
  red = value;
  printf ("redSliderValueChanged: [%d|%d|%d]\n", red, green, blue);
}

void
PCLViewer::greenSliderValueChanged (int value)
{
  green = value;
  printf ("greenSliderValueChanged: [%d|%d|%d]\n", red, green, blue);
}

void
PCLViewer::blueSliderValueChanged (int value)
{
  blue = value;
  printf("blueSliderValueChanged: [%d|%d|%d]\n", red, green, blue);
}
/*These are the public slot function member called whenever the red, green or blue slider value is changed
These functions just changes the member value accordingly to the slider value.
Here the point cloud is not updated; so until you release the slider you won’t see any change in the visualizer.
*/
PCLViewer::~PCLViewer ()
{
  delete ui;
}
//The destructor.
